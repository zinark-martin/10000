package leetcode.æ·±æœå¹¿æœ
import java.util.*
//https://leetcode-cn.com/problems/rotting-oranges/
/**
 * BFS å› ä¸ºæ±‚çš„æ˜¯æ—¶é—´ ä¹Ÿå°±æ˜¯å¤šå°‘è½® ä¹Ÿå°±æ˜¯å¹¿åº¦ä¸Šæœ‰å¤šå°‘å±‚
 * é‡ç‚¹: å› ä¸ºæ„ŸæŸ“ä¸€æ¬¡æ˜¯éœ€è¦å›ºå®šæ—¶é—´çš„ æ‰€ä»¥æ¯ä¸€æ¬¡æ„ŸæŸ“å°±æ˜¯æ¯ä¸ªè…çƒ‚çš„æ©˜å­å»
 * æ„ŸæŸ“å®ƒç›¸é‚»ç›¸é‚»ç›¸é‚»çš„å¥åº·æ©˜å­ è¿™ç®—åœ¨åŒä¸€æ¬¡æ—¶é—´ä¸­ä¹Ÿå«ä¸€è½®
 * ä½¿ç”¨é˜Ÿåˆ—å®ç°å¹¿åº¦ä¼˜å…ˆ é˜Ÿå­˜å…¥çš„æ˜¯è…çƒ‚æ©˜å­çš„åæ ‡
 * åˆ†ä¸¤ä¸ªé˜¶æ®µ:
 * 1.æ˜¯O(n*m)çš„åŒå±‚éå†æ¥è®°å½•æ–°é²œæ©˜å­çš„ä¸ªæ•° -> count++
 *  å¹¶æŠŠè…çƒ‚æ©˜å­åæ ‡æ”¾å…¥é˜Ÿåˆ—(åˆå§‹å±‚)
 * 2.é˜¶æ®µæ˜¯è¿›è¡Œä¸€å±‚ä¸€å±‚(BFS)åœ°æ„ŸæŸ“
 *  æ¯è½®éœ€è¦ä¸€åˆ†é’Ÿ æœ€åå¦‚æœè¿˜æœ‰å‰©ä½™çš„æ–°é²œæ©˜å­å°±è¿”å›-1
 * */
fun orangesRotting(grid: Array<IntArray>): Int {
    val queue: Queue<IntArray> = LinkedList()//æ¯ä¸€åªè…çƒ‚æ©˜å­éƒ½æ˜¯ä»¥å…¶åæ ‡å½¢å¼å­˜åœ¨
    var count = 0 // æ–°é²œæ©˜å­çš„æ•°é‡
    for (r in grid.indices)
        for (c in grid[0].indices) {
            if (grid[r][c] == 1) {
                count++ // æ–°é²œæ©˜å­+1
            } else if (grid[r][c] == 2) {
                queue.add(intArrayOf(r, c))
                // å­˜å…¥è…çƒ‚æ©˜å­çš„åæ ‡
            }
        } // æ­¤æ—¶æ‰¾å‡ºäº†åˆå§‹çŠ¶æ€ä¸­ è…çƒ‚çš„æ©˜å­çš„åæ ‡ å’Œæ–°é²œæ©˜å­çš„æ•°é‡

    var round = 0
    // round è¡¨ç¤ºè…çƒ‚çš„è½®æ•°ï¼Œå³åˆ†é’Ÿæ•°
    while (count > 0 && !queue.isEmpty()) {
        // æœ‰æœªè…çƒ‚çš„æ©˜å­å¹¶ä¸”é˜Ÿåˆ—ä¸ç©º(å°±æ˜¯å­˜åœ¨è…çƒ‚æ©˜å­çš„åæ ‡)
        round++
        // å…ˆè¡¨ç¤ºè¿˜éœ€è¦ä¸€è½®æ—¶é—´ å³BFSå±‚æ•°+1
        for (i in queue.indices) {
            //queueçš„å¤§å°è¡¨ç¤ºå½“å‰è¿™ä¸€è½®ä¸­ æœ‰å¤šå°‘è…çƒ‚çš„æ©˜å­
            //æˆ‘ä»¬ä¾æ¬¡å»åˆ¤æ–­è¿™äº›è…çƒ‚çš„æ©˜å­æ˜¯å¦èƒ½æ„ŸæŸ“å®ƒå‘¨å›´çš„æ–°é²œæ©˜å­
            //ç„¶åå°†æ„ŸæŸ“çš„æ–°é²œæ©˜å­å…¥é˜Ÿåˆ— å¹¶å°†æ–°é²œæ•°é‡--
            //forå¾ªç¯ç»“æŸæ—¶ ä¸Šä¸€å±‚(è½®)è…çƒ‚æ©˜å­å·²ç»è¢«å‰”é™¤å‡ºé˜Ÿåˆ— å› ä¸ºå®ƒä»¬ä¸ä¸‹ä¸€å±‚çš„æ„ŸæŸ“æ— å…³
            //è¿™æ—¶é˜Ÿåˆ—ä¸­çš„éƒ½æ˜¯åœ¨è¿™ä¸€è½®ä¸­æ–°è¢«æ„ŸæŸ“çš„æ©˜å­ å®ƒä»¬å°†åœ¨ä¸‹ä¸€è½®æ„ŸæŸ“åˆ«çš„æ©˜å­
            val orange = queue.poll()
            val r = orange[0]// å±‚
            val c = orange[1]// åˆ—
            //ä¸ŠğŸ‘†
            if (r - 1 >= 0 && grid[r - 1][c] == 1) {
                // ä¸Šé¢è¿˜æœ‰å±‚ å¹¶ä¸”ä¸Šé¢æ˜¯ä¸€åªæ–°é²œæ©˜å­
                grid[r - 1][c] = 2 // æ„ŸæŸ“å®ƒ
                count-- // æ–°é²œæ©˜å­å°‘ä¸€ä¸ª
                queue.add(intArrayOf(r - 1, c)) // å°†æ„ŸæŸ“çš„æ©˜å­åæ ‡å…¥é˜Ÿåˆ—(ä½“ç°BFS)
            }
            //ä¸‹ğŸ‘‡
            if (r + 1 < grid.size && grid[r + 1][c] == 1) {
                grid[r + 1][c] = 2
                count--
                queue.add(intArrayOf(r + 1, c))
            }
            //ğŸ‘ˆå·¦
            if (c - 1 >= 0 && grid[r][c - 1] == 1) {
                grid[r][c - 1] = 2
                count--
                queue.add(intArrayOf(r, c - 1))
            }
            //å³ğŸ‘‰
            if (c + 1 < grid[0].size && grid[r][c + 1] == 1) {
                grid[r][c + 1] = 2
                count--
                queue.add(intArrayOf(r, c + 1))
            }
        }
    }
    return if (count > 0) -1 else round
}
